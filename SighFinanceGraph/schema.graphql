type SIGH_Instrument @entity {
    "ID is contract address"
    id: ID!
    creationBlockNumber: BigInt!
    address: Bytes!
    name: String!
    symbol: String!
    decimals: BigInt!
    priceETH: BigDecimal!
    priceUSD: BigDecimal!
    treasury: Bytes!
    speedController: Bytes!

    totalSupply_WEI: BigInt!
    totalSupply: BigDecimal!

    recentSIGHBurnt_WEI: BigInt!
    recentSIGHBurnt: BigDecimal!
    totalSIGHBurnt_WEI: BigInt!
    totalSIGHBurnt: BigDecimal!

    currentCycle: BigInt!
    currentSchedule: BigInt!
    currentInflation: BigDecimal!

    currentMintSpeed_WEI: BigInt!
    currentMintSpeed: BigDecimal!
    currentBurnSpeed_WEI: BigInt!
    currentBurnSpeed: BigDecimal!

    mintSnapshots: [MintSnapshot!]! @derivedFrom(field:"instrument_sigh")
    oracle: Bytes!
}

type MintSnapshot @entity {
    id: ID!
    priceETH: BigDecimal!
    priceUSD: BigDecimal!
    instrument_sigh: SIGH_Instrument! 
    schedule: BigInt!
    inflationRate: BigDecimal!
    mintedAmount_WEI: BigInt!
    mintedAmount: BigDecimal!
    totalSupply_WEI: BigInt!
    totalSupply: BigDecimal!
    mintSpeed_WEI: BigInt!
    mintSpeed: BigDecimal!
    burnSpeed_WEI: BigInt!
    burnSpeed: BigDecimal!
    totalSighBurnt_WEI: BigInt!
    totalSighBurnt: BigDecimal!
    minter: Bytes!
    blockNumber: BigInt!
}






type Instrument @entity {
    id: ID!

    instrumentAddress: Bytes!
    iTokenAddress: Bytes!
    interestRateStrategyAddress: Bytes!
    sighStreamStorageAddress: Bytes!
    sighStreamImplAddress: Bytes!

    oracle: Bytes!

    priceETH: BigDecimal! 
    priceUSD: BigDecimal! 

    name: String!
    symbol: String!
    underlyingInstrumentName: String!
    underlyingInstrumentSymbol: String!
    decimals: BigInt!

    isActive: Boolean!
    isFreezed: Boolean!
    borrowingEnabled: Boolean!
    usageAsCollateralEnabled: Boolean!
    isStableBorrowRateEnabled: Boolean!

    baseLTVasCollateral: BigInt!
    liquidationThreshold: BigInt!
    liquidationBonus: BigInt!

    "availableLiquidity_WEI : totalLiquidity_WEI - totalPrincipalBorrows_WEI, present tokenized instrument quantity available with SIGH Finance's Lending Pool for borrowing. (not adjusted by decimal)"    
    availableLiquidity_WEI: BigInt!
    availableLiquidity: BigDecimal!
    availableLiquidityETH: BigDecimal!
    availableLiquidityUSD: BigDecimal!

    borrowFeeDue_WEI: BigInt! 
    borrowFeeDue: BigDecimal! 
    borrowFeeDueETH: BigDecimal!
    borrowFeeDueUSD: BigDecimal!

    borrowFeeEarned_WEI: BigInt! 
    borrowFeeEarned: BigDecimal! 
    borrowFeeEarnedETH: BigDecimal!
    borrowFeeEarnedUSD: BigDecimal!

    totalCompoundedLiquidityWEI: BigInt!
    totalCompoundedLiquidity: BigDecimal!
    totalCompoundedLiquidityETH: BigDecimal!
    totalCompoundedLiquidityUSD: BigDecimal!

    totalCompoundedStableBorrowsWEI: BigInt!
    totalCompoundedStableBorrows: BigDecimal!
    totalCompoundedStableBorrowsETH: BigDecimal!
    totalCompoundedStableBorrowsUSD: BigDecimal!

    totalCompoundedVariableBorrowsWEI: BigInt!
    totalCompoundedVariableBorrows: BigDecimal!
    totalCompoundedVariableBorrowsETH: BigDecimal!
    totalCompoundedVariableBorrowsUSD: BigDecimal!

    "totalCompoundedEarnings_WEI : totalCompoundedEarningsSTABLEInterest_WEI + totalCompoundedEarningsVARIABLEInterest_WEI, present tokenized instrument's total quantity earned through Borrowing Interest Rates. (not adjusted by decimal)"    
    totalBorrowingEarnings_WEI: BigInt!
    totalBorrowingEarnings: BigDecimal!
    totalBorrowingEarningsETH: BigDecimal!
    totalBorrowingEarningsUSD: BigDecimal!

    "stableBorrowInterestRate : Current Stable Borrow Interest Rate (not adjusted by decimal)"    
    stableBorrowInterestRate: BigInt!
    "stableBorrowInterestPercent : Current Stable Borrow Interest Rate (Adjusted by decimal)"    
    stableBorrowInterestPercent: BigDecimal!

    "variableBorrowInterestRate : Current Variable Borrow Interest Rate (not adjusted by decimal)"    
    variableBorrowInterestRate: BigInt!
    "variableBorrowInterestPercent : Current Variable Borrow Interest Rate (Adjusted by decimal)"        
    variableBorrowInterestPercent: BigDecimal!
    "supplyIndex : Index for Accuring instrument quantity as Supply Interest"    
    variableBorrowIndex: BigInt!

    utilizationRate: BigDecimal!
    utilizationRatePercent: BigDecimal!

    "supplyInterestRate : Current Supply Interest Rate (not adjusted by decimal)"    
    supplyInterestRate: BigInt!
    "supplyInterestRate : Current Supply Interest Rate (Adjusted by decimal, i.e Interest APY )"    
    supplyInterestRatePercent: BigDecimal!
    "supplyIndex : Index for Accuring instrument quantity as Supply Interest"    
    supplyIndex: BigInt!


    lifeTimeDeposits_WEI: BigInt!
    lifeTimeDeposits: BigDecimal!
    lifeTimeDepositsETH: BigDecimal!
    lifeTimeDepositsUSD: BigDecimal!

    lifeTimeBorrows_WEI:  BigInt!
    lifeTimeBorrows:  BigDecimal!
    lifeTimeBorrowsETH: BigDecimal!
    lifeTimeBorrowsUSD: BigDecimal!

    lifeTimeStableBorrows_WEI: BigInt!
    lifeTimeStableBorrows: BigDecimal!
    lifeTimeStableBorrowsETH: BigDecimal!
    lifeTimeStableBorrowsUSD: BigDecimal!

    lifeTimeVariableBorrows_WEI: BigInt!
    lifeTimeVariableBorrows: BigDecimal!
    lifeTimeVariableBorrowsETH: BigDecimal!
    lifeTimeVariableBorrowsUSD: BigDecimal!

    lifeTimeBorrowsRepaid_WEI: BigInt!
    lifeTimeBorrowsRepaid: BigDecimal!
    lifeTimeBorrowsRepaidETH: BigDecimal!
    lifeTimeBorrowsRepaidUSD: BigDecimal!

    totalLiquiditySIGHAccuredWEI: BigInt!
    totalLiquiditySIGHAccured: BigDecimal!

    currentLiquiditySIGHAccuredWEI: BigInt!
    currentLiquiditySIGHAccured: BigDecimal!

    totalBorrowingSIGHAccuredWEI: BigInt!
    totalBorrowingSIGHAccured: BigDecimal!

    currentBorrowingSIGHAccuredWEI: BigInt!
    currentBorrowingSIGHAccured: BigDecimal!






    isListedWithSIGH_Mechanism: Boolean!
    isSIGHMechanismActivated: Boolean!

    SIGH_Supply_Index: BigInt!
    SIGH_Supply_Index_lastUpdatedBlock: BigInt!

    SIGH_Borrow_Index: BigInt!
    SIGH_Borrow_Index_lastUpdatedBlock: BigInt!


    fromBlockNumber: BigInt!
    toBlockNumber: BigInt!

    present_SIGH_Side: String!
    present_DeltaBlocks: BigInt!
    present_Clock: BigInt!

    present_maxVolatilityLimitSuppliers: BigInt!
    present_maxVolatilityLimitSuppliersPercent: BigDecimal!
    present_maxVolatilityLimitBorrowers: BigInt!
    present_maxVolatilityLimitBorrowersPercent: BigDecimal!

    "% of total Protocol Protocol Volatility"
    present_percentTotalVolatility: BigDecimal! 
    "Instrument volatility in 24 hrs"
    present_total24HrVolatilityETH: BigInt!    
    present_total24HrVolatilityUSD: BigDecimal!

    present_percentTotalVolatilityLimitAmount: BigDecimal!
    "Instrument volatility * maxVolatilityLimit"
    present_24HrVolatilityLimitAmountETH: BigInt!  
    present_24HrVolatilityLimitAmountUSD: BigDecimal!

    present_SIGH_Suppliers_Speed_WEI: BigInt!
    present_SIGH_Suppliers_Speed: BigDecimal!

    present_SIGH_Borrowers_Speed_WEI: BigInt!
    present_SIGH_Borrowers_Speed: BigDecimal!

    present_SIGH_Staking_Speed_WEI: BigInt!
    present_SIGH_Staking_Speed: BigDecimal!


    present_PrevPrice_ETH: BigDecimal! 
    present_PrevPrice_USD: BigDecimal! 

    present_OpeningPrice_ETH: BigDecimal! 
    present_OpeningPrice_USD: BigDecimal! 


    SIGH_Distribution_History: [SIGH_Distribution!]! @derivedFrom(field:"instrumentAddress")

    timeStamp: BigInt!
}



type SIGH_Distribution @entity {
    id: ID!
    instrumentAddress: Instrument! 
    fromBlockNumber: BigInt!
    toBlockNumber: BigInt!
    distribution_Side: String!
    suppliers_Speed_WEI: BigInt!
    suppliers_Speed: BigDecimal!
    borrowers_Speed_WEI: BigInt!
    borrowers_Speed: BigDecimal!
    staking_Speed_WEI: BigInt!
    staking_Speed: BigDecimal!    

}


# type SIGHSpeedController @entity {
#     "ID is contract address"
#     id: ID!
#     ProtocolAddress: Bytes!
#     TreasuryAddress: Bytes!
#     ProtocolDistributionSpeed: BigInt!
#     TreasuryDistributionSpeed: BigInt!
#     recentlyDrippedToProtocol: BigInt!
#     totalAmountDrippedToProtocol: BigInt!
#     recentlyDrippedToTreasury: BigInt!
#     totalAmountDrippedToTreasury: BigInt!
#     totalAmountDripped: BigInt!
#     ReservoirBalance: BigInt!
# }

# type SIGHTreasury @entity {
#     "ID is contract address"
#     id: ID!
#     sightroller_address: Bytes!
#     sigh_token: Bytes!

#     tokenBeingDripped: Bytes!
#     DripSpeed: BigInt!
#     isDripAllowed: Boolean!

#     maxTransferAmount: BigInt!

#     recentlySIGHBurned: BigInt!
#     totalSIGHBurned: BigInt!
# }

# # Sightroller global variables
# type Sightroller @entity {
#     "ID is set to 1"
#     id: ID!
#     "Address of price oracle the Sightroller uses, NewPriceOracle event "
#     priceOracle: Bytes
#     "Factor used to determine repayAmount for liquidating, NewCloseFactor event"
#     closeFactor: BigInt
#     "The percent bonus liquidators get for liquidating, NewLiquidationIncentive event"
#     liquidationIncentive: BigInt
#     "Max assets a single user can enter, NewMaxAssets event"
#     maxAssets: BigInt
#     "NewPauseGuardian event"
#     pauseGuardian: Bytes
#     "NewGsighRate event"
#     gsighRate: BigInt

#     sighRate: BigInt
# }






# # Supported Markets
# type Market @entity { 
#     "CToken address"
#     id: ID!
#     symbol: String!
#     name: String!
#     "The cToken contract balance of underlying asset"
#     cash: BigDecimal!
#     "Exchange rate of tokens / cTokens"
#     exchangeRate:  BigDecimal!

#     underlyingAddress: Bytes!
#     underlyingName: String!
#     "Underlying price of token in ETH (ex. 0.007 DAI)"
#     underlyingPrice: BigDecimal!
#     underlyingSymbol: String!
#     "Underlying token price in USD"
#     underlyingPriceUSD: BigDecimal!
#     "Underlying token decimal length"
#     underlyingDecimals: Int!

#     "CToken supply. CTokens have 8 decimals"
#     totalSupply: BigDecimal!

#     "Borrows (amount) in the market"
#     totalBorrows: BigDecimal!

#     "Reserves stored in the contract"
#     reserves: BigDecimal!

#     "Yearly borrow rate. With 2102400 blocks per year"
#     borrowRate: BigDecimal!

#     "Yearly supply rate. With 2104400 blocks per year"
#     supplyRate: BigDecimal!

#     "Collateral factor determining how much one can borrow"
#     collateralFactor: BigDecimal!

#     "Number of borrowers active in the market"
#     numberOfBorrowers: Int!

#     "Number of suppliers active in the market"
#     numberOfSuppliers: Int!

#     "Address of the interest rate model"
#     interestRateModelAddress: Bytes!

#     # Fields that are not in compounds api

#     "Block the market is updated to"
#     accrualBlockNumber: Int!

#     "Timestamp the market was most recently updated"
#     blockTimestamp: Int!

#     "The history of the markets borrow index return (Think S&P 500)"
#     borrowIndex: BigDecimal!

#     "The factor determining interest that goes to reserves"
#     reserveFactor: BigInt!

#     "Gsigh Distribution Speed, GsighSpeedUpdated event "
#     gsighSpeed: BigInt!

#     "DistributedSupplierGsigh event"
#     totalGsighDistributedToSuppliers: BigInt!

#     "DistributedBorrowerGsigh event"
#     totalGsighDistributedToBorrowers: BigInt!

#     "NewPendingAdmin event"
#     pendingAdmin: Bytes!

#     "NewAdmin event"
#     admin: Bytes!    

#     "NewSightroller event"
#     sightroller: Bytes!    

#     "SIGH Distribution Speed, SIGHSpeedUpdated event "
#     sighSpeed: BigInt!

#     blockNumberWhenSpeedWasUpdated: Int!

#     savePriceSnapshot: BigInt!

#     sighAccuredInCurrentCycle: BigInt!

# }






# # Users within the protocol
# type Account @entity {
#     "User wallet address"
#     id: ID!
#     "Array of markets user is in"
#     tokens: [UserAccount_IndividualMarketStats!]! @derivedFrom(field: "account")
#     "how many times user has been liquidated"
#     countLiquidated: Int!
#     "how many times user has liquidated others"
#     countLiquidator: Int!
#     "True if user has ever borrowed"
#     hasBorrowed: Boolean!

#     # The following values are added by the JS Wrapper, and must be calculated with the most up
#     # to date values based on the block delta for market.exchangeRate and market.borrowIndex
#     # They do not need to be in the schema, but they will show up in the explorer playground

#     # "If less than 1, the account can be liquidated
#     # health: BigDecimal!
#     # "Total assets supplied by user"
#     # totalBorrowValueInEth: BigDecimal!
#     # "Total assets borrowed from user"
#     # totalCollateralValueInEth: BigDecimal!
# }






# # Stats for an accounts borrow and supply of an asset
# type UserAccount_IndividualMarketStats @entity {
#     "Concatenation of CToken address and user address"
#     id: ID!
#     "Relation to market"
#     market: Market!
#     "Symbol of the cToken"
#     symbol: String!
#     "Relation to user"
#     account: Account!
#     "Hashes of all user transactions"
#     transactionHashes: [Bytes!]!
#     "Times of all user transactions"
#     transactionTimes: [Int!]!
#     "Block number this asset was updated at in the contract"
#     accrualBlockNumber: Int!
#     "True if user is entered, false if they are exited"
#     enteredMarket: Boolean!
#     "CToken balance of the user"
#     cTokenBalance: BigDecimal!
#     "Total amount of underlying supplied"
#     totalUnderlyingSupplied: BigDecimal!
#     "Total amount of underling redeemed"
#     totalUnderlyingRedeemed: BigDecimal!
#     "The value of the borrow index upon users last interaction"
#     accountBorrowIndex: BigDecimal!
#     "Total amount underlying borrowed, exclusive of interest"
#     totalUnderlyingBorrowed: BigDecimal!
#     "Total amount underlying repaid"
#     totalUnderlyingRepaid: BigDecimal!
#     "Current borrow balance stored in contract (exclusive of interest since accrualBlockNumber)"
#     storedBorrowBalance: BigDecimal!

#     # The following values are added by the JS Wrapper, and must be calculated with the most up
#     # to date values based on the block delta for market.exchangeRate and market.borrowIndex
#     # They do not need to be in the schema, but they will show up in the explorer playground

#     # supplyBalanceUnderlying: BigDecimal!
#     # FORMULA: supplyBalanceUnderlying = cTokenBalance * market.exchangeRate

#     # lifetimeSupplyInterestAccrued: BigDecimal!
#     # FORMULA: lifetimeSupplyInterestAccrued = supplyBalanceUnderlying - totalUnderlyingSupplied + totalUnderlyingRedeemed

#     # borrowBalanceUnderlying: BigDecimal!
#     # FORMULA: borrowBalanceUnderlying = storedBorrowBalance * market.borrowIndex / accountBorrowIndex

#     # lifetimeBorrowInterestAccrued: BigDecimal!
#     # FORMULA: lifetimeBorrowInterestAccrued = borrowBalanceUnderlying - totalUnderlyingBorrowed + totalUnderlyingRepaid
# }






# type TokenBalancesData @entity {
#     "Token Address is the ID"
#     id: ID!
#     symbol: String!
#     balance: BigInt!
#     totalDripped: BigInt!
# }
